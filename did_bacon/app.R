## -----------------------------------------------------------------------------
## app.R
## Kyle Butts, CU Boulder Economics 
## 
## This is a shiny application to highlight Goodman-Bacon decomposition
## -----------------------------------------------------------------------------

library(shiny)
library(shinyWidgets)
library(tidyverse)
library(fixest)
library(did)
library(bacondecomp)

#source("https://raw.githubusercontent.com/kylebutts/templates/master/ggplot_theme/theme_kyle.R")


responsive_col <- function(xs, ..., sm = xs, md = sm, lg = md, xl = lg, xs_offset = 0, sm_offset = 0, md_offset = 0, lg_offset = 0, xl_offset = 0){

	if (!is.numeric(xs) || (xs < 1) || (xs > 12))
		stop("column width must be between 1 and 12")
	if (!is.numeric(sm) || (sm < 1) || (sm > 12))
		stop("column width must be between 1 and 12")
	if (!is.numeric(md) || (md < 1) || (md > 12))
		stop("column width must be between 1 and 12")
	if (!is.numeric(lg) || (lg < 1) || (lg > 12))
		stop("column width must be between 1 and 12")
	if (!is.numeric(xl) || (xl < 1) || (xl > 12))
		stop("column width must be between 1 and 12")
	
	# Only add class if option is different from one smaller viewport
	colClass <- paste0("col-", xs)
	if(sm != xs) colClass <- paste0(colClass, " col-sm-", sm)
	if(md != sm) colClass <- paste0(colClass, " col-md-", md)
	if(lg != md) colClass <- paste0(colClass, " col-lg-", lg)
	if(xl != lg) colClass <- paste0(colClass, " col-xl-", xl)
	
	# Add offset
	if(xs_offset > 0) colClass <- paste0(colClass, " offset-", xs_offset)
	if(sm_offset > 0) colClass <- paste0(colClass, " offset-sm-", sm_offset)
	if(md_offset > 0) colClass <- paste0(colClass, " offset-md-", md_offset)
	if(lg_offset > 0) colClass <- paste0(colClass, " offset-lg-", lg_offset)
	if(xl_offset > 0) colClass <- paste0(colClass, " offset-xl-", xl_offset)

	div(class = colClass, ...)
}



ui <- fluidPage(
	theme = bslib::bs_theme(bootswatch = "flatly"),
	fluidRow(
		column(10, offset = 1,
			   plotOutput("dgp")
		)
	),
	fluidRow(
		responsive_col(xs = 12, lg = 2, lg_offset = 2,
			   h2("Treatment Group 1"),
			   sliderInput("te1", "Treatment Effect:", 2, min = -10, max = 10),
			   sliderInput("te_m1", "Treatment Effect Slope:", value = 0.4, min = -1, max = 1, step = 0.05),
			   sliderInput("g1", "Treatment Date:", value = 2004, min = 2001, max = 2019, step = 1, sep = "")
		),
		responsive_col(xs = 12, lg = 2, 
			   h2("Treatment Group 2"),
			   sliderInput("te2", "Treatment Effect:", 1, min = -10, max = 10),
			   sliderInput("te_m2", "Treatment Effect Slope:", value = 0.2, min = -1, max = 1, step = 0.05),
			   sliderInput("g2", "Treatment Date:", value = 2012, min = 2001, max = 2019, step = 1, sep = "")
		),
		responsive_col(xs = 12, lg = 2, 
			   h2("Panel"),
			   sliderInput("panel", "Panel Years:", c(2000, 2020), min = 1980, max = 2030, step = 5, sep = "")
		),
		responsive_col(xs = 12, lg = 2, 
			   h3("Presets"),
			   shinyWidgets::radioGroupButtons(
			   	inputId = "btn_presets",
			   	label = "",
			   	choices = c(
			   		"None", "Homogeneous Effects", "Heterogeneity in Levels", 
			   		"Heterogeneity in Levels (w/ Slopes)", "Heterogeneity in Slopes", 
			   		"Heterogeneity in Levels and Slopes"
			   	),
			   	direction = "vertical"
			   )
		)
	),
	fluidRow(hr(style="margin-bottom: 40px;")),
	fluidRow(
		responsive_col(xs=12, lg = 8, lg_offset = 2, uiOutput("estimate"))
	),
	fluidRow(hr(style="margin-bottom: 40px;")),
	fluidRow(
		responsive_col(xs = 12, lg = 6, plotOutput("did_one", width = "100%")),
		responsive_col(xs = 12, lg = 6, plotOutput("did_two", width = "100%"))
	),
	fluidRow(hr(style="margin-bottom: 40px;")),
	fluidRow(
		responsive_col(xs = 12, lg = 6, plotOutput("did_three", width = "100%")),
		responsive_col(xs = 12, lg = 6, plotOutput("did_four", width = "100%"))
	)
)

server <- function(input, output, session) {
	
	# Gen Data
	df <- reactive({
	
		g3 <- 0L
		te3 <- 0
		te_m3 <- 0
		
		tibble(unit = 1:1000) %>%
			mutate(
				state = sample(1:40, n(), replace = TRUE),
				unit_fe = rnorm(n(), state/5, 1),
				group = runif(n()),
				group = case_when(
					group < 0.33 ~ "Group 1",
					group < 0.66 ~ "Group 2",
					TRUE ~ "Group 3"
				),
				g = case_when(
					group == "Group 1" ~ input$g1,
					group == "Group 2" ~ input$g2,
					group == "Group 3" ~ g3,
				)
			) %>% 
			expand_grid(year = input$panel[1]:input$panel[2]) %>%
			# Year FE
			group_by(year) %>% mutate(year_fe = rnorm(n(), (year - input$panel[1])/4, 1)) %>% ungroup() %>%
			mutate(
				treat = (year >= g) & (g %in% input$panel[1]:input$panel[2]),
				rel_year = if_else(g == 0L, Inf, as.numeric(year - g)),
				rel_year_binned = case_when(
					rel_year == Inf ~ Inf,
					rel_year <= -6 ~ -6,
					rel_year >= 6 ~ 6,
					TRUE ~ rel_year
				),
				error = rnorm(n(), 0, 1),
				# Level Effect
				te = 
					(group == "Group 1") * input$te1 * (year >= input$g1) + 
					(group == "Group 2") * input$te2 * (year >= input$g2) +
					(group == "Group 3") * te3       * (year >= g3),
				# dynamic Effect
				te_dynamic = 
					(group == "Group 1") * (year >= input$g1) * input$te_m1 * (year - input$g1) + 
					(group == "Group 2") * (year >= input$g2) * input$te_m2 * (year - input$g2) +
					(group == "Group 3") * (year >= g3)       * te_m3       * (year - g3),
				y0 = unit_fe + year_fe + error,
				# With TE level shift 
				counterfactual = unit_fe + year_fe + te + error, 
				dep_var = unit_fe + year_fe + te + te_dynamic + error
			)
	})
	
	subset_data <- function(df, treat_g, control_g) {
		# Treated vs. Untreated
		if(control_g == 0) {
			min_year <- -Inf
			max_year <- Inf
		# Early vs. Late (before late is treated)
		} else if(treat_g < control_g) {
			min_year <- -Inf
			max_year <- control_g
		# Late vs. Early (after early is treated)	
		} else if(control_g < treat_g) {
			min_year <- control_g
			max_year <- Inf
		}
		
		df_subset <- df %>%
			filter(g %in% c(treat_g, control_g)) %>% 
			filter(year >= min_year & year < max_year) %>%
			mutate(
				treated = case_when(
					g == treat_g ~ "Treat Group",
					g == control_g ~ "Control Group"
				)
			)
		
		return(df_subset)
	}
	
	# Two by Twos
	two_by_twos <- reactive({
		df <- df()
		
		# Weights from	`bacondecomp` package
		gs <- unique(df$g)
		
		two_by_twos <- expand_grid(treat_g = gs, control_g = gs) %>% 
			filter(treat_g != control_g) %>% 
			filter(treat_g != 0) %>% 
			mutate(weight = 0, est = 0)
		
		for(i in 1:nrow(two_by_twos)) { 
			
			treat_g = two_by_twos[i,][["treat_g"]]
			control_g = two_by_twos[i,][["control_g"]]
			
			df_subset <- subset_data(df, treat_g, control_g)
			
			# Weights from `bacondecomp` 
			
			# Treated vs. Untreated
			if(control_g == 0) {
				n_u <- sum(df_subset$g == control_g)
				n_k <- sum(df_subset$g == treat_g)
				n_ku <- n_k / (n_k + n_u)
				D_k <- mean(df_subset[df_subset$g == treat_g, ][["treat"]])
				V_ku <- n_ku * (1 - n_ku) * D_k * (1 - D_k)
				weight1 <- (n_k + n_u) ^ 2 * V_ku
			# Early vs. Late (before late is treated)
			} else if(treat_g < control_g) {
				n_k <- sum(df_subset$g == treat_g)
				n_l <- sum(df_subset$g == control_g)
				n_kl <- n_k / (n_k + n_l)
				D_k <- mean(df_subset[df_subset$g == treat_g, ][["treat"]])
				D_l <- mean(df_subset[df_subset$g == control_g, ][["treat"]])
				V_kl <- n_kl * (1 - n_kl) * (D_k - D_l) / (1 - D_l) * (1 - D_k) / (1 - D_l)
				weight1 <- ( (n_k + n_l) * (1 - D_l) ) ^ 2 * V_kl
			# Late vs. Early (after early is treated)	
			} else if(control_g < treat_g) {
				n_k <- sum(df_subset$g == control_g)
				n_l <- sum(df_subset$g == treat_g)
				n_kl <- n_k / (n_k + n_l)
				D_k <- mean(df_subset[df_subset$g == control_g, ][["treat"]])
				D_l <- mean(df_subset[df_subset$g == treat_g, ][["treat"]])
				V_kl <- n_kl * (1 - n_kl) * (D_l / D_k) * (D_k - D_l) / (D_k)
				weight1 <- ( (n_k + n_l) * D_k) ^ 2 * V_kl
			}
			
			# Estimate TWFE on subsample
			df_subset$treat = df_subset$treat & (df_subset$g == treat_g)
			
			est <- fixest::feols(dep_var ~ treat | unit + year, data = df_subset) %>% 
				coef() %>% .[["treatTRUE"]]
			
			# Store results
			two_by_twos[i, "weight"] <- weight1
			two_by_twos[i, "est"] <- est
			
		}
		
		two_by_twos <- two_by_twos %>% 
			mutate(weight = weight/sum(weight))
		
		two_by_twos
	})
	
	# Panel length changed
	observeEvent(input$panel, {
		updateSliderInput(inputId = "g1", min = input$panel[1] + 2, max = input$panel[2] - 2)
		updateSliderInput(inputId = "g2", min = input$panel[1] + 2, max = input$panel[2] - 2)
	})
	
	# Change treatment year
	observeEvent(input$g1 | input$g2, {
				updateSliderInput(inputId = "g1", min = input$panel[1] + 2, max = input$g2 - 2)
				updateSliderInput(inputId = "g2", min = input$g1 + 2, max = input$panel[2] - 2)
		})
	
	# Presets
	observeEvent(input$btn_presets, {
		if(input$btn_presets == "None") {
			
		}
		else if(input$btn_presets == "Homogeneous Effects") {
			updateSliderInput(inputId = "te1", value = input$te1)
			updateSliderInput(inputId = "te2", value = input$te1)
			updateSliderInput(inputId = "te_m1", value = 0)
			updateSliderInput(inputId = "te_m2", value = 0)
		}
		else if(input$btn_presets == "Heterogeneity in Levels") {
			updateSliderInput(inputId = "te1", value = 2)
			updateSliderInput(inputId = "te2", value = input$te1 * 2)
			updateSliderInput(inputId = "te_m1", value = 0)
			updateSliderInput(inputId = "te_m2", value = 0)
		}
		else if(input$btn_presets == "Heterogeneity in Levels (w/ Slopes)") {
			updateSliderInput(inputId = "te1", value = 2)
			updateSliderInput(inputId = "te2", value = input$te1 * 2)
			updateSliderInput(inputId = "te_m1", value = 0.1)
			updateSliderInput(inputId = "te_m2", value = 0.1)
		}
		else if(input$btn_presets == "Heterogeneity in Slopes") {
			updateSliderInput(inputId = "te1", value = input$te1)
			updateSliderInput(inputId = "te2", value = input$te1)
			updateSliderInput(inputId = "te_m1", value = 0.05)
			updateSliderInput(inputId = "te_m2", value = 0.2)
		}
		else if(input$btn_presets == "Heterogeneity in Levels and Slopes") {
			updateSliderInput(inputId = "te1", value = 2)
			updateSliderInput(inputId = "te2", value = input$te1 * 2)
			updateSliderInput(inputId = "te_m1", value = 0.05)
			updateSliderInput(inputId = "te_m2", value = 0.2)
		}
	})
	
	output$dgp <- renderPlot({
		df <- df()
		
		df_avg <- df %>% group_by(group, year) %>% summarize(dep_var = mean(dep_var), .groups = 'drop')
		
		max_y <- max(df_avg$dep_var)
		
		ggplot() + 
			geom_line(data = df_avg, mapping = aes(y = dep_var, x = year, color = group), size = 1.5) +
			geom_vline(xintercept = input$g1 - 0.5, linetype = "dashed") + 
			geom_vline(xintercept = input$g2 - 0.5, linetype = "dashed") +
			theme_minimal(base_size = 16) + # , title_pos = "left"
			theme(legend.position = "bottom") +
			labs(y = "Outcome", x = "Year", title = "Data-Generating Process", color = NULL) + 
			scale_y_continuous(expand = expansion(add = .5)) + 
			scale_color_manual(values = c("Group 1" = "#d2382c", "Group 2" = "#497eb3", "Group 3" = "#8e549f")) +
			# guides(color = guide_legend(nrow = 2)) + 
			geom_label(data = data.frame(x = input$g1 - 0.4, y = max_y + 0.5, label = "◀ Treatment Starts"), label.size=NA,
					   mapping = aes(x = x, y = y, label = label), size = 4.23, hjust = 0L, fontface = 2, inherit.aes = FALSE) +
			geom_label(data = data.frame(x = input$g2 - 0.4, y = max_y + 0.75, label = "◀ Treatment Starts"), label.size=NA,
					   mapping = aes(x = x, y = y, label = label), size = 4.23, hjust = 0L, fontface = 2, inherit.aes = FALSE)
	}, res = 96)
	
	
	plot_bacon <- function(df, two_by_twos, treat_g, control_g) {

		df_subset <- subset_data(df, treat_g, control_g)

		est <- two_by_twos[two_by_twos$treat_g == treat_g & two_by_twos$control_g == control_g, ][["est"]]
		weight <- two_by_twos[two_by_twos$treat_g == treat_g & two_by_twos$control_g == control_g, ][["weight"]]
				
		# Plot -----------------------------------------------------------------
		
		df_avg <- df %>% group_by(group, year) %>% summarize(dep_var = mean(dep_var), .groups = 'drop')
		
		df_subset_avg <- df_subset %>% 
			group_by(group, treated, year) %>% 
			summarize(dep_var = mean(dep_var), counterfactual = mean(counterfactual), .groups = 'drop')
		
		max_y = max(df_avg$dep_var)
		
		# Assemble text
		subtitle <- glue::glue("<i style='color: #D55E00;'>Estimate:</i> {round(est,2)} and <i style='color: #D55E00;'>Weight:</i> {round(weight,3)}")
		
		# Treated vs. Untreated
		if(control_g == 0) {
			title <- glue::glue("**Treated:** {treat_g} <br/> **Control:** Never Treated")
			
		# Early vs. Late (before late is treated)
		} else if(treat_g < control_g) {
			title <- glue::glue("**Treated:** {treat_g} <br/> **Control:** {control_g} (before treated)")

		# Late vs. Early (after early is treated)	
		} else if(control_g < treat_g) {
			title <- glue::glue("**Treated:** {treat_g} <br/> **Control:** {control_g} (after treated)")
		}

		
		
		ggplot() + 
			# DGP
			geom_line(data = df_avg, 
					  mapping = aes(y = dep_var, x = year, group = group), color = "grey40", alpha = 0.6, size = 1) +
			# 2x2
			geom_line(data = df_subset_avg, mapping = aes(y = dep_var, x = year, group = treated, color = treated), size = 1.5) + 
			geom_line(data = df_subset_avg, mapping = aes(y = counterfactual, x = year, group = treated, color = treated), linetype = "dashed", size = 1.5, alpha = 0.6) + 
			geom_vline(xintercept = treat_g - 0.5, linetype = "dashed") + 
			geom_label(data = data.frame(x = treat_g - 0.4, y = max_y + 0.75, label = "◀ Treatment Starts"), label.size=NA,
					   mapping = aes(x = x, y = y, label = label), size = 4.23, hjust = 0L, fontface = 2, inherit.aes = FALSE) + 
			labs(y = "Outcome", x = "Year", color = NULL, linetype = NULL, title = title, subtitle = subtitle) + 
			scale_y_continuous(expand = expansion(add = .5)) + 
			scale_color_manual(values = c("Treat Group" = "#d2382c", "Control Group" = "#497eb3")) + 
			theme_minimal(base_size = 16) + # , title_pos = "left"
			theme(
				legend.position = "bottom",
				plot.title = ggtext::element_markdown(face = "plain", lineheight = 1.2),
				plot.subtitle = ggtext::element_markdown(size = 18)
			)
		
	}
	
	output$estimate <- renderUI({
		
		true_te <- df() %>% filter(treat == TRUE) %>% summarize(te = mean(te + te_dynamic)) %>% .[[1,1]]
		
		two_by_twos <- two_by_twos()
		
		est <- round(two_by_twos$est, 2)
		weight <- round(two_by_twos$weight, 2)
		
		
		temp <- c()
		for(i in 1:length(est)) {
			temp[i] <- glue::glue("{est[i]}*{weight[i]}")
		}
		
		str <- glue::glue("$$\\hat\\tau = {paste0(temp, collapse=' + ')} = {round(sum(est * weight), 2)} $$")
		true <- glue::glue()
		
		
		list(h3("True Effect: "), withMathJax(glue::glue("$$\\tau = {round(true_te,2)}$$")), h3('TWFE Estimate:'), withMathJax(str))
	})
	
	
	output$did_one <- renderPlot({
		df <- df()
		two_by_twos <- two_by_twos() 
		
		plot_bacon(df, two_by_twos, input$g1, 0)
	}, height = 500)
	
	output$did_two <- renderPlot({
		df <- df()
		two_by_twos <- two_by_twos() 
		
		plot_bacon(df, two_by_twos, input$g2, 0)
	}, height = 500)
	
	output$did_three <- renderPlot({
		df <- df()
		two_by_twos <- two_by_twos() 
		
		plot_bacon(df, two_by_twos, input$g1, input$g2)
	}, height = 500)
	
	output$did_four <- renderPlot({
		df <- df()
		two_by_twos <- two_by_twos() 
		
		plot_bacon(df, two_by_twos, input$g2, input$g1)
	}, height = 500)
}

# Run the application 
# For Testing
# input <- list(g1 = 2004L, g2 = 2012L, te1 = 2.0, te2 = 2.0, te_m1=1, te_m2=0.5, panel = c(2000, 2020))
# treat_g <- 2004
# control_g <- 0
# bacondecomp::bacon(dep_var ~ treat, data = df, id_var = "unit", time_var = "year")

shinyApp(ui = ui, server = server)


